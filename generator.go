package main

import (
	"io"
	"strings"
	"text/template"
)

func generateCode(genArgs *GeneratorArgs, out io.Writer) error {
	tmpl := template.Must(template.New("gen").
		Funcs(template.FuncMap{
			"join":      strings.Join,
			"isPointer": isPointer,
			"trimStar":  trimStar,
		}).
		Parse(tmplRaw))
	err := tmpl.Execute(out, genArgs)
	if err != nil {
		return err
	}
	return nil
}

func isPointer(name string) bool {
	return len(name) > 0 && name[0] == '*'
}

func trimStar(name string) string {
	return strings.TrimLeft(name, "*")
}

var tmplHeadRaw = `package {{.Package}}

// Code generated by "{{join .AllArgs " "}}"; DO NOT EDIT.

import (
	"encoding/json"
	"errors"

	{{ range .Imports -}} 
		"{{ . }}" 
	{{ end }}
) `

var tmplDeclarationRaw = `
type {{.Typed}} struct {
	{{.Interface}}
} `

var tmplMarshalRaw = `
func (t {{.Typed}}) MarshalJSON() ([]byte, error) {
	typedString := t.{{.Interface}}.typedjson(nil)
	wrapper := struct {
		T string
		V {{.Interface}}
	}{
		T: typedString,
		V: t.{{.Interface}},
	}
	return json.Marshal(&wrapper)
} `

var tmplUnmarshalRaw = `
func (t *{{.Typed}}) UnmarshalJSON(src []byte) error {
	var wrapper struct {
		T string
		V json.RawMessage
	}
	err := json.Unmarshal(src, &wrapper)
	if err != nil {
		return err
	}
	switch wrapper.T {
	{{- range .Structs }}
	{{if isPointer . -}}
	case "{{.}}":
		t.{{$.Interface}} = &{{trimStar . }}{}
	{{else -}}
	case "{{.}}":
		t.{{$.Interface}} = {{trimStar . }}{}
	{{- end }}
	{{- end }}
	default:
		return errors.New("unknown type")
	}
	if err := json.Unmarshal(wrapper.V, t.{{.Interface}}); err != nil {
		return err
	}
	return nil
}
`

var tmplMethodsRaw = `
{{ range $_, $name := .Structs }}
func (s {{$name}}) typedjson(*{{$.Typed}}) string {
	return "{{$name}}"
}
{{ end }}
`

var tmplRaw = strings.Join([]string{
	tmplHeadRaw,
	tmplDeclarationRaw,
	tmplMarshalRaw,
	tmplUnmarshalRaw,
	tmplMethodsRaw,
}, "\n")
